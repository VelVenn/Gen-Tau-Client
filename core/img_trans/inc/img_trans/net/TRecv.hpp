#pragma once

#include "img_trans/net/TReassembly.hpp"

#include "utils/TSignal.hpp"
#include "utils/TTypeRedef.hpp"

#include <arpa/inet.h>
#include <bits/types/struct_timeval.h>
#include <netinet/in.h>
#include <sys/socket.h>

#include <atomic>
#include <chrono>
#include <memory>
#include <optional>
#include <thread>

namespace gentau {
class TRecv
{
  public:
	using UniPtr    = std::unique_ptr<TRecv>;
	using SharedPtr = std::shared_ptr<TRecv>;
	using TimePoint = std::chrono::steady_clock::time_point;

	struct V4Addr
	{
		u32 ip   = 0;
		u16 port = 0;

		V4Addr(u32 _ipNetworkOrder, u16 _port) : ip(_ipNetworkOrder), port(_port) {}

		bool isValid() const { return ip != 0 && port != 0; }

		std::string toString() const noexcept
		{
			if (!isValid()) { return "Invalid IP"; }

			auto ipStrOpt = TRecv::V4Addr::ipToStr(ip);
			if (!ipStrOpt.has_value()) { return "Invalid IP"; }
			return std::move(ipStrOpt).value() + ":" + std::to_string(port);
		}

		static std::optional<V4Addr> create(const char* ipStr, u16 port)
		{
			auto ipOpt = strToIp(ipStr);
			if (!ipOpt.has_value()) { return std::nullopt; }
			return V4Addr(ipOpt.value(), port);
		}

		static std::optional<u32> strToIp(const char* ipStr)
		{
			u32 addr;
			if (inet_pton(AF_INET, ipStr, &addr) <= 0) { return std::nullopt; };
			return addr;
		}

		static std::optional<std::string> ipToStr(u32 ipNetworkOrder)
		{
			char str[INET_ADDRSTRLEN];
			if (inet_ntop(AF_INET, &ipNetworkOrder, str, INET_ADDRSTRLEN) == nullptr) {
				return std::nullopt;
			}
			return std::string(str);
		}
	};

  private:
	struct UdpSocket
	{
		int fd = -1;
		UdpSocket(int _fd) : fd(_fd) {}  // Allow implicit construction from int

		UdpSocket(const UdpSocket&)            = delete;  // Forbid copy
		UdpSocket& operator=(const UdpSocket&) = delete;

		UdpSocket(UdpSocket&& other) noexcept : fd(other.fd) { other.fd = -1; }
		UdpSocket& operator=(UdpSocket&& other) noexcept
		{
			if (this != &other) {
				closeSock();
				fd       = other.fd;
				other.fd = -1;
			}
			return *this;
		}

		// Allow implicit conversion to int for socket operations
		operator int() const { return fd; }

		~UdpSocket() { closeSock(); }

		void closeSock()
		{
			if (fd > -1) {
				::close(fd);
				fd = -1;
			}
		}
	};

  private:
	const TReassembly::SharedPtr reassembler;
	UdpSocket                    updSock      = -1;
	sockaddr_in                  listenAddr   = {};
	std::atomic<TimePoint>       lastRecvTime = TimePoint::min();

  public:
	TSignal<TRecv, i32> onRecvError;  // Passing errno code generated by recv() failure

  private:
	static constexpr i32     kRecvBufferSize = 4 * 1024 * 1024;  // 4MB
	static constexpr timeval kRecvTimeout    = { 0, 100'000 };   // 100ms

  private:
	// 这里必须放在所有字段的后面，以确保在析构时先停止线程，避免访问已销毁的成员变量。
	std::jthread recvThread;

  public:
	/**
	 * @brief: Start the receiving thread.
	 * @return: 0 on success, else the POSIX errno code of the failure reason.
	 *          - EBADF if the socket is not bound.
	 *          - other errno codes from setsockopt() failure.
	 * @note: Recieving thread will be abnormally stopped when these recv() 
	 *        failures happened:
	 *        - EBADF / EFAULT / EINVAL (FATAL error, will not retry)
	 *        - ENOMEM (if it was triggered 5 times continuously) 
	 * @note: NOT MT-SAFE! Ok to call this method multiple times, or call it when
	 *        the thread is already running without restart the thread.
	 */
	int start();

	/**
	 * @brief: Request to stop the receiving thread and wait for it to finish.
	 * @note: NOT MT-SAFE! Ok to call this method multiple times. In most cases,
	 *        this method does not need to be called manually.
	 */
	void stop();

	/**
	 * @brief: Request to stop the receiving thread without waiting.
	 * @note: NOT MT-SAFE! Ok to call this method multiple times. In most cases,
	 *        this method does not need to be called manually.
	 */
	void stopAsync();

  public:
	/**
	 * @brief: Get the last received time point. if no packet has been received,
	 *         it returns TimePoint::min().
	 * 
	 * @note: MT-SAFE
	 */
	TimePoint getLastRecvTime() const noexcept { return lastRecvTime.load(); }

  public:
	/**
	 * @brief: Bind to a specific IPv4 address and port.
	 *
	 * @return: 0 on success, else the POSIX errno code of the failure reason.
	 *          - EINVAL if the provided IP address string is invalid.
	 *          - other errno codes from socket() and bind() error.
	 * 
	 * @note: NOT MT-SAFE! Will stop the current receiving thread if 
	 *        it's running when calling this method.
	 */
	i32 bindV4(u16 port, const char* ip);

	/**
	 * @brief: Check if the socket is successfully bound.
	 * @note: NOT MT-SAFE!
	 */
	bool isBound() const noexcept { return updSock > -1; }

	/**
	 * @brief: Get the currently bound address. If not bound, returns std::nullopt.
	 * @note: NOT MT-SAFE!
	 */
	std::optional<V4Addr> getListenAddr() const noexcept
	{
		if (!isBound()) { return std::nullopt; }
		return V4Addr(listenAddr.sin_addr.s_addr, ::ntohs(listenAddr.sin_port));
	}

  public:
	/**
	 * @brief: Constructor of TRecv.
	 * @param _reassembler: A shared pointer to a TReassembly who is used for reassembling received packets.
	 * @param _port: The port to listen on.
	 * @param _ip: The IP address to bind to, only accept dotted-decimal notation.
	 * @throws: std::invalid_argument if reassembler is nullptr.
	 */
	explicit TRecv(
		TReassembly::SharedPtr _reassembler, u16 _port = 3334, const char* _ip = "127.0.0.1"
	);
	~TRecv();

	/**
	 * @brief: create a unique pointer to TRecv instance. 
	 * @param reassembler: A shared pointer to a TReassembly who is used for reassembling received packets.
	 * @param port: The port to listen on.
	 * @param ip: The IP address to bind to, only accept dotted-decimal notation (e.g., "127.0.0.1").
	 * @return: A unique pointer to the created TRecv instance.
	 * @throws: std::invalid_argument if reassembler is nullptr.
	 */
	[[nodiscard("Should not ignored the created TRecv::UniPtr")]] static UniPtr createUni(
		TReassembly::SharedPtr reassembler, u16 port = 3334, const char* ip = "127.0.0.1"
	)
	{
		return std::make_unique<TRecv>(reassembler, port, ip);
	}

	/**
	 * @brief: create a shared pointer to TRecv instance. 
	 * @param reassembler: A shared pointer to a TReassembly who is used for reassembling received packets.
	 * @param port: The port to listen on.
	 * @param ip: The IP address to bind to, only accept dotted-decimal notation (e.g., "127.0.0.1").
	 * @return: A shared pointer to the created TRecv instance.
	 * @throws: std::invalid_argument if reassembler is nullptr.
	 */
	[[nodiscard("Should not ignored the created TRecv::SharedPtr")]] static SharedPtr createShared(
		TReassembly::SharedPtr reassembler, u16 port = 3334, const char* ip = "127.0.0.1"
	)
	{
		return std::make_shared<TRecv>(reassembler, port, ip);
	}

	TRecv()                        = delete;  // Forbid default construction
	TRecv(const TRecv&)            = delete;  // Forbid copy or move
	TRecv& operator=(const TRecv&) = delete;
	TRecv(TRecv&&)                 = delete;
	TRecv& operator=(TRecv&&)      = delete;
};
}  // namespace gentau